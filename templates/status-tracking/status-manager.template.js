/**
 * Status Manager Template
 * Auto-generated by MCP Helper init-status command
 * 
 * This class manages project status tracking with a single source of truth
 * in PROJECT_STATUS.json and optional memory synchronization.
 */

import fs from 'fs-extra';
import path from 'path';

export class StatusManager {
  constructor(projectPath = process.cwd()) {
    this.projectPath = projectPath;
    this.statusFile = path.join(projectPath, 'PROJECT_STATUS.json');
    this.backupDir = path.join(projectPath, '.status-backups');
  }

  /**
   * Initialize status file if it doesn't exist
   */
  async initialize(projectName = '{{PROJECT_NAME}}') {
    if (!await fs.pathExists(this.statusFile)) {
      const initialStatus = {
        project: projectName,
        overall_completion: 0,
        last_updated: new Date().toISOString(),
        created_at: new Date().toISOString(),
        created_by: '{{USER_NAME}}',
        tracking_config: {
          weighted_completion: true,
          memory_sync: true,
          auto_update_claudemd: true
        },
        features: {},
        todos: [],
        critical_notes: [],
        metadata: {
          version: '1.0.0',
          schema: 'mcp-helper-status-v1'
        }
      };
      
      await this.writeStatus(initialStatus);
      return initialStatus;
    }
    
    return await this.readStatus();
  }

  /**
   * Read current status
   */
  async readStatus() {
    try {
      if (await fs.pathExists(this.statusFile)) {
        return await fs.readJson(this.statusFile);
      }
      return null;
    } catch (error) {
      console.error('Error reading status:', error);
      return null;
    }
  }

  /**
   * Write status with backup
   */
  async writeStatus(status) {
    try {
      // Create backup
      await this.createBackup();
      
      // Update timestamp
      status.last_updated = new Date().toISOString();
      
      // Write status
      await fs.writeJson(this.statusFile, status, { spaces: 2 });
      
      return true;
    } catch (error) {
      console.error('Error writing status:', error);
      return false;
    }
  }

  /**
   * Update specific feature completion
   */
  async updateFeature(featureName, completion, notes = null) {
    const status = await this.readStatus();
    if (!status) return false;
    
    if (!status.features) {
      status.features = {};
    }
    
    status.features[featureName] = {
      name: featureName,
      completion: Math.min(100, Math.max(0, completion)),
      last_updated: new Date().toISOString()
    };
    
    if (notes) {
      status.features[featureName].notes = notes;
    }
    
    // Recalculate overall completion
    if (status.tracking_config?.weighted_completion) {
      status.overall_completion = this.calculateWeightedCompletion(status.features);
    } else {
      status.overall_completion = this.calculateAverageCompletion(status.features);
    }
    
    return await this.writeStatus(status);
  }

  /**
   * Calculate weighted completion percentage
   */
  calculateWeightedCompletion(features) {
    // Default weights - can be customized per project
    const weights = {
      core_functionality: 0.4,
      documentation: 0.15,
      testing: 0.2,
      deployment: 0.15,
      optimization: 0.1
    };
    
    let totalWeight = 0;
    let weightedSum = 0;
    
    for (const [key, feature] of Object.entries(features)) {
      const weight = weights[key] || (1 / Object.keys(features).length);
      totalWeight += weight;
      weightedSum += (feature.completion || 0) * weight;
    }
    
    return totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 0;
  }

  /**
   * Calculate simple average completion
   */
  calculateAverageCompletion(features) {
    const values = Object.values(features);
    if (values.length === 0) return 0;
    
    const sum = values.reduce((acc, f) => acc + (f.completion || 0), 0);
    return Math.round(sum / values.length);
  }

  /**
   * Add a todo item
   */
  async addTodo(todo) {
    const status = await this.readStatus();
    if (!status) return false;
    
    if (!status.todos) {
      status.todos = [];
    }
    
    status.todos.push({
      id: `todo-${Date.now()}`,
      content: todo,
      status: 'pending',
      created_at: new Date().toISOString()
    });
    
    return await this.writeStatus(status);
  }

  /**
   * Update todo status
   */
  async updateTodo(todoId, newStatus) {
    const status = await this.readStatus();
    if (!status || !status.todos) return false;
    
    const todo = status.todos.find(t => t.id === todoId);
    if (todo) {
      todo.status = newStatus;
      todo.updated_at = new Date().toISOString();
      
      if (newStatus === 'completed') {
        todo.completed_at = new Date().toISOString();
      }
      
      return await this.writeStatus(status);
    }
    
    return false;
  }

  /**
   * Add critical note
   */
  async addCriticalNote(note) {
    const status = await this.readStatus();
    if (!status) return false;
    
    if (!status.critical_notes) {
      status.critical_notes = [];
    }
    
    // Avoid duplicates
    if (!status.critical_notes.includes(note)) {
      status.critical_notes.push(note);
      return await this.writeStatus(status);
    }
    
    return true;
  }

  /**
   * Create backup of current status
   */
  async createBackup() {
    try {
      if (!await fs.pathExists(this.statusFile)) {
        return null;
      }
      
      await fs.ensureDir(this.backupDir);
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupFile = path.join(this.backupDir, `status-backup-${timestamp}.json`);
      
      await fs.copy(this.statusFile, backupFile);
      
      // Keep only last 10 backups
      await this.cleanOldBackups();
      
      return backupFile;
    } catch (error) {
      console.error('Error creating backup:', error);
      return null;
    }
  }

  /**
   * Clean old backups (keep last 10)
   */
  async cleanOldBackups() {
    try {
      const files = await fs.readdir(this.backupDir);
      const backupFiles = files
        .filter(f => f.startsWith('status-backup-'))
        .sort()
        .reverse();
      
      if (backupFiles.length > 10) {
        const toDelete = backupFiles.slice(10);
        for (const file of toDelete) {
          await fs.remove(path.join(this.backupDir, file));
        }
      }
    } catch (error) {
      console.error('Error cleaning backups:', error);
    }
  }

  /**
   * Generate status report
   */
  async generateReport() {
    const status = await this.readStatus();
    if (!status) return 'No status found';
    
    let report = `# Project Status Report: ${status.project}\n\n`;
    report += `**Overall Completion**: ${status.overall_completion}%\n`;
    report += `**Last Updated**: ${status.last_updated}\n\n`;
    
    if (status.features && Object.keys(status.features).length > 0) {
      report += '## Features\n\n';
      for (const [key, feature] of Object.entries(status.features)) {
        report += `- **${feature.name}**: ${feature.completion}%`;
        if (feature.notes) {
          report += ` - ${feature.notes}`;
        }
        report += '\n';
      }
      report += '\n';
    }
    
    if (status.todos && status.todos.length > 0) {
      report += '## Todos\n\n';
      const pending = status.todos.filter(t => t.status === 'pending');
      const inProgress = status.todos.filter(t => t.status === 'in_progress');
      const completed = status.todos.filter(t => t.status === 'completed');
      
      if (inProgress.length > 0) {
        report += '### In Progress\n';
        for (const todo of inProgress) {
          report += `- ${todo.content}\n`;
        }
        report += '\n';
      }
      
      if (pending.length > 0) {
        report += '### Pending\n';
        for (const todo of pending) {
          report += `- ${todo.content}\n`;
        }
        report += '\n';
      }
      
      if (completed.length > 0) {
        report += '### Completed\n';
        for (const todo of completed) {
          report += `- ✓ ${todo.content}\n`;
        }
        report += '\n';
      }
    }
    
    if (status.critical_notes && status.critical_notes.length > 0) {
      report += '## Critical Notes\n\n';
      for (const note of status.critical_notes) {
        report += `- ⚠️ ${note}\n`;
      }
    }
    
    return report;
  }
}

export default StatusManager;